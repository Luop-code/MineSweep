大家好，本期视频是windows程序设计版本的扫雷
C/C++，好久没写C了，复习一下
由VS创建的Windows应用程序改编
自动生成的windows应用程序代码风格我不怎么喜欢
这是模仿MFC的底层进行了简单的包装
所有操作直接响应windows消息，调用windows API，代码效率上应该是没得挑剔了(笑)
下面先看文件
主要有winApp(.h,.cpp)、core(.h,.cpp)、stdafx(.h,.cpp)和resource1.h
winApp只保留了程序入口_tWinMain函数，其它操作转调用MyApp类的内容
stdafx只提供了常用、必要头文件包含
resource1.h提供了1个资源ID，就是我用画图画的，扫雷需要用到的位图图标
因为windows API中用于绘图的函数BitBlt可以选择源图像的部分数据，因此我可以把用到的所有图标集中在了一个文件内，绘制的时候再做选择
所有实际功能实现于core文件内
MyWnd类实现窗口类的注册和窗口的创建、绘制、显示
MyApp实现窗口的创建和程序的运行
其中Init函数仅仅是Register和Create简单的打包
Run函数就是运行起消息循环
GameCtrl类，就是一个结构体，包含了游戏相关的所有变量
然后就是一个函数指针类型pCallBack，指向消息响应函数
一个消息响应函数通用格式的宏CallBack(name)，只需输入函数返回类型和函数名即可生成函数声明
消息映射结构体MessageMap，将消息和消息响应函数绑定
和一堆消息响应函数的声明，定义在源文件core.cpp
OnChar为按键响应函数(准确的说是字符按键响应函数)
OnCreate为窗口创建响应函数，在创建窗口但还未显示时调用
OnPaint函数为窗口绘制响应函数，在窗口需要重绘时调用
鼠标左、中、右键响应函数，中键即鼠标滚轮，单击按下时调用
WndProc函数为窗口消息处理函数，不算消息响应，是在窗口类注册时与窗口类绑定，用此类创建的窗口产生的消息经过消息循环的翻译后会分配至活动窗口，调用此函数(WndProc)
这6个消息响应函数与windows消息的对应关系也可以在消息映射结构体数组cb_tab里看到，WM_改为On，剩余字符遵循驼峰命名法(参考的MFC消息处理函数)
WndProc函数具体工作，先对消息进行预处理，如果为任意(已在cb_tab注册的)鼠标消息，则先求出按下点在地图上的行号、列号
如果在地图外或游戏尚未开始，直接退出函数，不进行后续处理
否则在循环内查询cb_tab，以获得此次消息的类型，并调用对应的处理函数pf,另外不要问hWnd、message等变量哪儿来的，都是形参，CallBack宏展开后，WndProc是函数名，带hWnd、message、wParam、lParam4个参数
如果有cb_tab未处理的消息，则转调用系统提供的默认消息处理函数，WndProc是我们自己的消息处理，相当于对DefWindowProc的拦截，并让它兜底
CNT是求数组元素个数的宏
其它消息响应函数同样有上述4个形参，其中hWnd(消息源)、message(消息类型)是统一的，wParam和lParam为额外参数，不同的消息有不同含义，详情见帮助或百度
上面是windows程序设计理念的简单讲解，下面看游戏实现
先看这组宏，行列数，雷数，总方块数，游戏区相对于窗口原点(左上角)的偏移量：单位像素
涉及大小、数量、位置都可以更改，但单个方块(格子)的大小不可更改，因为
我加载的位图大小是固定的，或许有更麻烦但能实现的方式，但没去深究，也可能没有太大必要(32*32)看着挺舒服的
这是20行40列的效果
这是10行10列的效果，与窗口左上角的间隔都是30*30

在OnCreate中加载位图至bmp，初始化一些控制变量
OnPaint函数开始和结束的3行代码是必要的，然后两个分支分别处理绘制位图和绘制文本
但值得注意的是分支执行的条件是message等于0或者1，而因系统产生WM_PAINT消息而调用的OnPaint函数，message的值应为WM_PAINT(0x000F),因此两个分支都不是处理系统调用，而是我们在其它函数手动传参调用的
大家应该明白，OnPaint只是一个带4个参数的普通函数，只是因为在消息映射中将它与对应windows消息绑定且在WndProc中处理，才使它能自动处理WM_PAINT消息。而这个工程仅在DrawBlock中传入message(0)和DrawString中传入message(1)调用，分别对应OnPaint函数中的两个分支
在这个程序中，甚至不需要处理WM_PAINT消息，完全可以把OnPaint函数当成普通函数，因为我们所有的绘制需求都是确定的、明确的
DrawBlock函数，gc.rect为要输出位图的目标位置，gc.ir、gc.ic为要输出的小块位图(32*32)在整个位图中的行号列号，比如要绘制4时，gc.ir=1,gc.ic=1
接下来两行固定代码，调用OnPaint函数绘制，注意第二个参数为0即可
DrawString函数，用于游戏成功或失败结束时显示提示，也可自行扩展功能
pStr为OnPaint中第二个分支需要用到的全局变量，计算出输出文本的目标位置调用OnPaint，第二个参数传入1
DrawAllBlock，刷新所有方块，遍历gc.map，逐一调用DrawBlock函数
gc.map为同游戏区域大小的二维数组，每个元素取值在0~14之间，对应位图的一个小块，或者说是位图的索引数组
CreateMines函数，创建雷区，数据存放至gc.mines和gc.data，gc.data为gc.map同样大小的数组，一一对应，取值仅为0(非地雷)或者1(地雷)
产生一个0~TOTAL_BLOCK-1的随机数，如果为与首次单击位置或者之前已生成雷的位置重合则跳出for循环，j与i必不相等，重新生成随机数
如果循环到最后都没有重合，则j==i，把数据记录在gc.mines,这里生成的v是雷方块序号，为(行号*列数+列号)，需反推出行号、列号再记录进gc.data
创建gc.data的目的是简化计算，单击一个方块需统计它周围八邻域的雷的数量，二维数组比较方便查找，已生成雷数量自增，直至所有雷生成完成
统计r行c列处周围8个方块的雷的数量，行号为r-1至r+1，列号为c-1至c+1
因gc.data元素取值仅为0和1，可直接累加获取雷(1)的数量而不是判断、自增
这里重复统计了r行c列处的数据，但不是问题，因为此函数调用的前提是此方块不为雷(否则直接游戏结束了)，gc.data[r][c]=0，不影响结果
GameOver函数，输入1个参数，游戏结束的原因或者说游戏结果都行
先显示出所有雷，然后更改游戏状态，根据游戏结果显示提示字符串
ResetGame函数，复位所有游戏有关的变量，复位显示(包括清除提示字符串和刷新游戏区域)
DisposeOneClick函数，处理一次左键单击，主体内容的运行条件为gc.map[r][c]等于0(未翻开)或者12(标记为问号)且r、c在有效范围内
IsValidCoord进行简单的判断，指出r、c是否有效
如果r行c列处为地雷，直接游戏结束，传入1表示游戏失败
否则统计此方块周围雷数v1,用v1+2所在的块绘制此方块，对应位图中的所有数字块
这样写是为了简便，从map元素到位图块索引的映射关系可以自行定义，位图也可以自制，把周围为0的方块显示为问号也是可以的
gc.remain自减，如果剩下未明确的方块小于等于总雷数，则游戏结束，游戏成功(剩下的方块全是雷，扫雷成功)
如果v1为0，则周围一圈全不为雷，因此可以放心的点开，而这不应该让玩家去做，可在此自动翻开
当然，这里即使重复执行DisposeOneClick(r,c)也不会造成无限递归，因为gc.map[r][c]已被修改为v1+2 = 2，无法通过外层检验
OnChar函数，字符按键响应函数，响应的是WM_CHAR消息而不是WM_KEYDOWN什么的，目前只处理了小写s的情况，可自行扩展
OnCreate和OnPaint已经讲过，不再赘述
OnLButtonDown,gc.firstClick变量只在此处置1，标记是否为游戏开始后第一次左键单击，如果是，则避开此次单击的位置创建雷区，毕竟扫雷的隐藏规则第一次单击不会触雷
这里用的是两个if而不是if else，因为第一次单击也是有效单击，创建雷区之后需要接着处理单按，而不是直接退出函数
OnMButtonDown，中键响应，对此方块周围3*3(包括自身)的9个方块执行左键单击操作，注意，如果标记为旗子则不会被翻开，如果已被翻开也不会重复执行操作，一般用于确定周围没有雷的时候快速扫雷
你也可以在一个完全未翻开的区域按下中键，但那相当于豪赌
OnRButtonDown，使一个方块在未翻开、旗子、问号之间轮转，重绘此方块，更新gc.map
讲解完毕，进入演示
演示完毕，主要是我进行的操作(鼠标、键盘输入)没法儿录制，不好演示，建议自己玩
另外，视频录制过程发现了代码中几处可优化的地方，顺手改了，但右键响应函数里面还有一个BUG，也不算难改，对游戏影响不大，就留着吧
拜拜








































